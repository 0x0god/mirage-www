---
updated: 2022-04-08
authors:
  - name: Hannes Mehnert
    uri: https://hannes.robur.coop
subject: "MirageOS unikernels at robur"
permalink: 2022-04-08.robur
---

At [Robur](https://robur.coop), we have created many unikernels and services over the years using MirageOS, like [OpenVPN](https://builds.robur.coop/job/openvpn-router/), [CalDAV](https://builds.robur.coop/job/caldav/), a [*Let’s Encrypt*](https://letsencrypt.org/) [solver using DNS](https://builds.robur.coop/job/dns-letsencrypt/), [DNS Resolver](https://builds.robur.coop/job/dns-resolver/), authoritative [DNS Servers storing in a git remote](https://builds.robur.coop/job/dns-primary-git/), and other [reproducible binaries for deployment](https://builds.robur.coop/). We chose OCaml because of its advanced security, compiler speed, and automated memory management. Read more about how Robur benefits from OCaml and MirageOS [on our website](https://robur.coop/Our%20Work/Technology-Employed#OCaml).

Most recently, we worked on [producing and deploying binary unikernels](https://mirage.io/blog/deploying-mirageos-robur), funded by the European Union under the [NGI pointer](https://pointer.ngi.eu) programme.

### OpenVPN

Robur started the development of OpenVPN, a virtual private network protocol, in C rather than OCaml. This choice showed its weaknesses, so we revised it multiple times with an extension to address these issues; however, it soon became clear we needed to start from the beginning and develop it in OCaml using existing libraries and parsers. OCaml improved the project by enhancing security and minimising our codebase.

We created OpenVPN as a MirageOS unikernel to forward all traffic to a single IP address or local network NAT through the OpenVPN tunnel. To increase security even further, we designed a fail-safe that dropped all packages (rather than sending them unencrypted) when the OpenVPN tunnel was down.

This project was funded by [Prototypefund](https://prototypefund.de) in 2019. The [code is available](https://github.com/roburio/openvpn).

### CalDAV

Robur started the CalDAV project back in 2017 with a grant from the [Prototype Fund](https://prototypefund.de), which came with the stipulation that it had to be created within six months! Thus the first version of CalDAV emerged from those efforts. Afterward, [Tarides](https://tarides.com) sponsored Robur so we could continue CalDAV’s development and draft an inital CardDAV implementation, resulting in the version now available.

As you might’ve guessed from the name, CalDAV is a protocol to synchronise calendars, and it works on a robust server that’s relatively easy to configure and maintain. This enables more people to run our own digital infrastructure rather than rely on an outside source. Robur’s CalDAV provides considerable security, due to its minimal codebase, and stores its data on Git for version control. We even set up a live *test server* at [calendar.robur.coop](calendar.robur.coop) that contains the [calDavZAP user interface](https://inf-it.com/open-source/clients/caldavzap/), accessible with any username and password.

CalDAV also comes with some client control with its ability to be tracked and reverted, so you can remove entries from undesirable behavior. Plus, it can be exported and converted to/from other formats!

Robur’s tests of the basic tasks for maintaining a digital calendar, like adding or modifying an event, have all successfully passed with several different CalDAV clients, but we hope to develop CalDAV further by adding notifications on updates via email and integrating an address book. If you’re interested in investing or donating in CalDAV, please contact us through [our website](https://robur.coop/).

The code for [CalDAV](https://github.com/roburio/caldav) is also released to opam-repository, the code for [CardDAV](https://git.robur.io/linse/carddav) is not yet integrated nor released.

### DNS Projects

Robur engineers have created robust DNS Projects, like our [‘Let’s Encrypt’](https://letsencrypt.org/)-Certified [DNS Solver](https://builds.robur.coop/job/dns-letsencrypt/), a [DNS Resolver](https://builds.robur.coop/job/dns-resolver/), and an authoritative [DNS Server](https://builds.robur.coop/job/dns-primary-git/). As a refresher, users navigate the Internet using domain names, addresses in cyberspace; DNS stands for Domain Name System. These systems take the domain name (something easy to remember, like robur.coop), and reroute them to the IP address (not easily remembered, like 193.30.40.138). The term *IP address* is short for Internet Protocol address, and its numbers point to a specific server, city, state/region, postal code, etc. In other words, it’s the actual machine’s address. These IP addresses take users to the website's files, and they’re what enable you to send and receive emails, too. DNS stores all these key values (with caching) in a decentralised hierarchy, making it fault-tolerant to minimise problems.

Robur’s authoritative DNS server delegates responsibility for a specific domain and provides mapping information for it, ensuring that the user gets to the correct IP address. At the other end of the process, Robur’s DNS resolver finds the exact server to handle the user’s request. To keep the codebase minimal for security and simplicity, they included only the elements absolutely necessary. The let's encrypt unikernel waits for certificate requests in the zones (encoded as TLSA records), and uses let's encrypt DNS challenge to have these signed to certificates, again stored in the zones. Of course, certificates that will soon become invalid will be updated by dns-letsencrypt-secondary. This unikernel does not need any persistent storage, it leaves this to the dns-primary-git.

We’ve been developing these DNS projects since 2017, which serve a multitude of functions in the Robur ecosystem. Our domains (like nqsb.io and robur.coop) use our DNS server as an authoritative server, and we also use a caching resolver for our biannual [MirageOS retreats](http://retreat.mirage.io) in Marrakech. Additionally, any MirageOS unikernel can use our client to resolve domain names - using the dns-client devices, or [happy-eyeballs](https://github.com/roburio/happy-eyeballs), so it’s also beneficial to the OCaml community at large. Robur uses expressive OCaml types (GADT), so we can ensure a given query has a specific shape, like an address record query results in a set of IPv4 addresses.

Robur's DNS implementation can process extensions like dynamic updates, notifications, zone transfers, and request authentications. It can be installed through opam, as all OCaml tools and libraries, and you can find our DNS code’s [library](https://github.com/mirage/ocaml-dns) and unikernels ([dns-primary-git](https://github.com/roburio/dns-primary-git), [dns-secondary](https://github.com/roburio/dns-secondary), [dns-letsencrypt](https://github.com/roburio/dns-letsencrypt-secondary), and [dns-resolver](https://git.robur.io/robur/dns-resolver) on GitHub.

If you are interested in supporting or learning more about Robur’s work, please get in touch with us at [robur.coop](https://robur.coop/Contact).
